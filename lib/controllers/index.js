const encoding = require('encoding')
const url = require('url')
const _convert = require('bbcode-to-markdown')
const path = require('path')
const fs = require('fs-extra')
const jsonParseSafe = require('json-stringify-safe')
const moment = require('moment')
const extend = require('extend')
const _ = require('lodash')

const config = require('../config')
const Exporter = require('../exporter')
const Importer = require('../importer')
const utils = require('../../static/lib/utils')
const helpers = require('../helpers')

const db = require('../database')
const Groups = require('../database/groups')
const Categories = require('../database/categories')
const User = require('../database/users')
const Messaging = require('../database/messaging')
const Topics = require('../database/topics')
const Posts = require('../database/posts')
const privileges = require('../database/privileges')

const DELETE_BATCH_LIMIT = 50
const CONVERT_BATCH_LIMIT = 50

const DELIVERABLES_TMP_DIR = path.join(__dirname, '../../static/tmp')
const DELIVERABLES_TMP_URL = path.join('/plugins/nodebb-plugin-import/tmp')

fs.ensureDirSync(DELIVERABLES_TMP_DIR)
fs.ensureDirSync(path.join(__dirname, '/tmp'))

const defaults = require('../config/defaults').postImport

const Controllers = {
	_config: defaults,
	'html-to-md': _convert.convertHtmlToMarkdown,
	'bbcode-to-md': _convert.bbcodeToMarkdown,
}

Controllers.config = (config, val) => {
	if (config != null) {
		if (typeof config === 'object') {
			utils.recursiveIteration(config)
			Controllers._config = extend(true, {}, defaults, config)
		} else if (typeof config === 'string') {
			if (val != null) {
				Controllers._config = Controllers._config || {}
				Controllers._config[config] = utils.resolveType(val)
			}
			return Controllers._config[config]
		}
	}

	return Controllers._config
}

Controllers.state = (state) => {
	if (state != null) {
		Controllers._state = state
	}
	return Controllers._state
}

Controllers.renderAdminPage = (req, res /* , next */ ) => {
	/*
		Make sure the route matches your path to template exactly.

		If your route was:
			myforum.com/some/complex/route/
		your template should be:
			templates/some/complex/route.tpl
		and you would render it like so:
			res.render('some/complex/route')
	*/

	res.render('admin/plugins/import', {})
}

Controllers.postImportToolsAvailble = () => {
	const state = Controllers.state()
	return (!state || state.now === 'idle') /* && fs.pathExistsSync(LAST_IMPORT_TIMESTAMP_FILE) */
}

Controllers.init = async () => {
	await db.init()
}

Controllers.setupConvert = () => {
	const cconf = Controllers.config().contentConvert

	let parseBefore, parseMain, parseAfter
	if (cconf.parseBefore && cconf.parseBefore.enabled && cconf.parseBefore.js) {
		parseBefore = helpers.buildFn(cconf.parseBefore.js)
	}

	if (cconf.mainConvert && _.isFunction(Controllers[cconf.mainConvert])) {
		parseMain = Controllers[cconf.mainConvert]
	}

	if (cconf.parseAfter && cconf.parseAfter.enabled && cconf.parseAfter.js) {
		parseAfter = helpers.buildFn(cconf.parseAfter.js)
	}

	Controllers.convert = async (content = '', type, id) => {
		try {
			if (parseBefore) {
				content = parseBefore(content, encoding, url)
			}
			if (parseMain) {
				content = parseMain(content)
			}
			if (parseAfter) {
				content = parseAfter(content, encoding, url)
			}
		} catch (e) {
			console.warn(`${type} with id=\`${id}\` and content=\`${content}\`, threw an error during convert, so it was skipped, error= \`${e}\``)
		}

		return content
	}
}

Controllers.getUsersCsv = async (req, res) => {
	if (!Controllers.postImportToolsAvailble()) {
		throw {
			error: 'Cannot download file at the moment.'
		}
	}

	let content = 'index,email,username,clear_text_autogenerated_password,imported_password,_uid,uid,joindate\n'
	let index = 0

	const total = await User.count()

	console.log(`Exporting ${total} users as csv`)

	await User.each(async (user) => {
		const __imported_original_data__ = utils.jsonParseSafe((user || {}).__imported_original_data__, {})
		if (user && __imported_original_data__._uid) {
			content += `${index},${user.email},${user.username},${__imported_original_data__._tmp_autogenerated_password},${__imported_original_data__._password},${__imported_original_data__._uid},${user.uid},${user.joindate}\n`
		}
		index += 1
	})

	const filename = 'users.csv'
	const filepath = path.join(DELIVERABLES_TMP_DIR, `/${filename}`)
	const fileurl = `${DELIVERABLES_TMP_URL}/${filename}`

	await fs.writeFile(filepath, content)

	return {
		filename,
		fileurl,
		filepath
	}

	// res.send({
	// 	filename,
	// 	fileurl,
	// 	filepath
	// })
}

Controllers.getUsersJson = async () => {
	if (!Controllers.postImportToolsAvailble()) {
		throw {
			error: 'Cannot download file at the moment.'
		}
	}

	const total = await User.count()

	console.log(`Exporting ${total} users as JSON`)

	let content = []
	let index = 0

	await User.each(async (user) => {
		const __imported_original_data__ = utils.jsonParseSafe((user || {}).__imported_original_data__, {})

		if (user && __imported_original_data__._uid) {
			content.push({
				"index": index,
				"email": user.email,
				"username": user.username,
				"clear_text_autogenerated_password": __imported_original_data__._tmp_autogenerated_password ? `"${__imported_original_data__._tmp_autogenerated_password }"` : null,
				"imported_password": __imported_original_data__._password ? `"${__imported_original_data__._password}"` : null,
				"_uid": __imported_original_data__._uid,
				"uid": user.uid,
				"joindate": user.joindate,
			})
		}
	})

	content = jsonParseSafe(content)

	const filename = 'users.json'
	const filepath = path.join(DELIVERABLES_TMP_DIR, `/${filename}`)
	const fileurl = `${DELIVERABLES_TMP_URL}/${filename}`

	await fs.writeFile(filepath, content)

	return {
		filename,
		fileurl,
		filepath
	}
	// res.send({
	// 	filename,
	// 	fileurl,
	// 	filepath
	// })
}

Controllers.import = async () => {
	Controllers.state({
		now: 'busy'
	})
	await db.init()
	await privileges.init()

	await Exporter.init(config)
	await Exporter.setup()

	Importer.setup(Exporter, config)
	await Importer.start()
	Controllers.state({
		now: 'idle'
	})
}

Controllers.deleteExtraFieldsUsers = async () => {
	const total = await User.count()
	let count = 0

	await User.each(async (user) => {
		count += 1
		const __imported_original_data__ = utils.jsonParseSafe((user || {}).__imported_original_data__, {})
		if (user && __imported_original_data__._uid) {
			await db.deleteObjectField(`user:${user.uid}`, '__imported_original_data__')
		}
		await Controllers.saveProgress({
			phase: 'deleteExtraFields:users',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: DELETE_BATCH_LIMIT
	})
}

Controllers.deleteExtraFieldsMessages = async () => {
	const keys = await Messaging.count()
	const total = keys.length
	let count = 0

	await Messaging.each(async (message) => {
		count += 1
		if (message && message.__imported_original_data__) {
			await db.deleteObjectField(`message:${message.mid}`, '__imported_original_data__')
		}
		await Controllers.saveProgress({
			phase: 'deleteExtraFields:messages',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: DELETE_BATCH_LIMIT
	})

}

Controllers.deleteExtraFieldsGroups = async () => {
	const total = await Groups.count()
	let count = 0

	await Groups.each(async (group) => {
		count += 1
		if (group && group.__imported_original_data__) {
			await db.deleteObjectField(`group:${group.name}`, '__imported_original_data__')
		}
		await Controllers.saveProgress({
			phase: 'deleteExtraFields:groups',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: DELETE_BATCH_LIMIT
	})
}

Controllers.deleteExtraFieldsCategories = async () => {
	const total = await Categories.count()
	let count = 0

	await Categories.each(async (category) => {
		count += 1
		if (category.__imported_original_data__) {
			await db.deleteObjectField(`category:${category.cid}`, '__imported_original_data__')
		}
		await Controllers.saveProgress({
			phase: 'deleteExtraFields:categories',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: DELETE_BATCH_LIMIT
	})
}

Controllers.deleteExtraFieldsTopics = async () => {
	const total = await Topics.count()
	let count = 0

	await Topics.each(async (topic) => {
		if (topic.__imported_original_data__) {
			await db.deleteObjectField(`topic:${topic.tid}`, '__imported_original_data__')
		}
		await Controllers.saveProgress({
			phase: 'deleteExtraFields:topics',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: DELETE_BATCH_LIMIT
	})
}

Controllers.deleteExtraFieldsPosts = async () => {
	const total = await Posts.count()
	let count = 0

	await Posts.each(async (post) => {
		count += 1
		if (post && post.__imported_original_data__) {
			await db.deleteObjectField(`post:${post.pid}`, '__imported_original_data__')
		}
		await Controllers.saveProgress({
			phase: 'deleteExtraFields:posts',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: DELETE_BATCH_LIMIT
	})
}

Controllers.deleteExtraFields = async () => {
	if (!Controllers.postImportToolsAvailble()) {
		throw {
			error: 'Cannot delete now.'
		}
	}

	if (!Controllers._config.deleteExtraFields) {
		return
	}

	await Controllers.deleteExtraFieldsUsers()
	await Controllers.deleteExtraFieldsMessages()
	await Controllers.deleteExtraFieldsGroups()
	await Controllers.deleteExtraFieldsTopics()
	await Controllers.deleteExtraFieldsPosts()

	if (!Controllers._importer) {
		Controllers._importer = require('../importer/')
	}
	await Controllers._importer.deleteTmpImportedSetsAndObjects()
}

Controllers.convertUsers = async () => {
	const total = await User.count()
	let count = 0

	await User.each(async (user) => {
		count += 1
		const __imported_original_data__ = utils.jsonParseSafe((user || {}).__imported_original_data__, {})
		if (user && __imported_original_data__._uid && utils.resolveType(__imported_original_data__._signature)) {
			await db.setObjectField(
				`user:${user.uid}`,
				'signature',
				await Controllers.convert(__imported_original_data__._signature, 'signature', user.uid),
			)
		}
		await Controllers.saveProgress({
			phase: 'convert:convertUsers',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: CONVERT_BATCH_LIMIT
	})
}

Controllers.convertMessages = async () => {
	const keys = await Messaging.count()
	const total = keys.length
	let count = 0

	await Messaging.each(async (message) => {
		count += 1
		const __imported_original_data__ = utils.jsonParseSafe((message || {}).__imported_original_data__, {})
		if (message && __imported_original_data__._content) {
			await db.setObjectField(
				`message:${message.mid}`,
				'content',
				await Controllers.convert(__imported_original_data__.content, 'content', message.mid),
			)
		}
		await Controllers.saveProgress({
			phase: 'convert:convertMessages',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: CONVERT_BATCH_LIMIT
	})
}

Controllers.convertGroups = async () => {
	const total = await Groups.count()
	let count = 0
	await Groups.each(async (group) => {
		const __imported_original_data__ = utils.jsonParseSafe((group || {}).__imported_original_data__, {})
		if (group && __imported_original_data__._name && __imported_original_data__._description) {
			await db.setObjectField(`group:${group.name}`,
				'description',
				await Controllers.convert(__imported_original_data__._description, 'group', group.name),
			)
		}
		await Controllers.saveProgress({
			phase: 'convert:convertGroups',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: CONVERT_BATCH_LIMIT
	})
}

Controllers.convertCategories = async () => {
	const total = await Categories.count()
	let count = 0
	const rconf = Controllers.config().contentConvert.convertRecords

	await Categories.each(async (category) => {
		count += 1
		const __imported_original_data__ = utils.jsonParseSafe((category || {}).__imported_original_data__, {})
		if (__imported_original_data__._cid) {
			await Promise.all([
				(async () => {
					const convertedName = await Controllers.convert(__imported_original_data__._name, 'category:name', category.cid)
					await db.setObjectField(`category:${category.cid}`, 'name', await Controllers.convert(__imported_original_data__._name))
					await db.setObjectField(`category:${category.cid}`, 'slug', `${category.cid}/${helpers.slugify(convertedName)}`)
				})(),
				(async () => {
					if (rconf.categoriesDescriptions && __imported_original_data__._description) {
						const description = await Controllers.convert(__imported_original_data__._description, 'category:description', category.cid)
						await Promise.all([
							db.setObjectField(`category:${category.cid}`, 'descriptionParsed', description),
							db.setObjectField(`category:${category.cid}`, 'description', description)
						])
					}
				})()
			])
		}
		await Controllers.saveProgress({
			phase: 'convert:convertCategories',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: CONVERT_BATCH_LIMIT
	})
}

Controllers.convertTopics = async (_mainPids = {}) => {
	const total = await Topics.count()
	let count = 0
	const rconf = Controllers.config().contentConvert.convertRecords

	await Topics.each(async (topic) => {
		count += 1
		_mainPids[topic.mainPid] = 1

		const __imported_original_data__ = utils.jsonParseSafe((topic || {}).__imported_original_data__, {})
		if (topic && (rconf.topicsTitle || rconf.topicsContent) && __imported_original_data__._tid) {
			await Promise.all([
				(async () => {
					if (rconf.topicsTitle && __imported_original_data__._title) {
						const convertedTitle = await Controllers.convert(__imported_original_data__._title, 'title', topic.tid)
						await db.setObjectField(`topic:${topic.tid}`, 'title', convertedTitle)
						await db.setObjectField(`topic:${topic.tid}`, 'slug', `${topic.tid}/${helpers.slugify(convertedTitle)}`)
					}
				})(),
				(async () => {
					if (rconf.topicsContent && __imported_original_data__._content) {
						await db.setObjectField(`post:${topic.mainPid}`, 'content', await Controllers.convert(__imported_original_data__._content, 'post', topic.mainPid))
					}
				})()
			])
		}
		await Controllers.saveProgress({
			phase: 'convert:convertTopics',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: CONVERT_BATCH_LIMIT
	})
}

Controllers.convertPosts = async (_mainPids) => {
	const total = await Posts.count()
	let count = 0
	if (!_mainPids) {
		console.log('main pids not provided, populating main pids')
		_mainPids = {}
		await Topics.each(async (topic) => {
			_mainPids[topic.mainPid] = 1
		}, {
			async: true,
			eachLimit: CONVERT_BATCH_LIMIT
		})
		console.log('populated main pids')
	}
	await Posts.each(async (post) => {
		count += 1
		const __imported_original_data__ = utils.jsonParseSafe((post || {}).__imported_original_data__, {})
		if (post && __imported_original_data__._pid && !_mainPids[post.pid] && __imported_original_data__._content) {
			// console.log(`before: ${post.pid},${post.tid}`, __imported_original_data__._content)
			const content = await Controllers.convert(__imported_original_data__._content, 'post', post.pid)
			// console.log(`after: ${post.pid},${post.tid}`, content)
			await db.setObjectField(`post:${post.pid}`, 'content', content)
		}
		await Controllers.saveProgress({
			phase: 'convert:convertPosts',
			count,
			total
		})
	}, {
		async: true,
		eachLimit: CONVERT_BATCH_LIMIT
	})
}

Controllers.convertAll = async () => {
	if (!Controllers.postImportToolsAvailble()) {
		throw {
			error: 'Cannot convert now.'
		}
	}

	const rconf = Controllers.config().contentConvert.convertRecords

	let phases = [{
		phase: 'convertUsers',
		conf: rconf.usersSignatures
	}, {
		phase: 'convertMessages',
		conf: rconf.messages
	}, {
		phase: 'convertGroups',
		conf: rconf.groups
	}, {
		phase: 'convertCategories',
		conf: rconf.categoriesNames || rconf.categoriesDescriptions
	}, {
		phase: 'convertTopics',
		conf: rconf.topicsTitle || rconf.topicsContent || rconf.postsContent
	}, {
		phase: 'convertPosts',
		conf: rconf.postsContent
	}]

	for await (const {
		phase,
		conf
	} of phases) {
		if (conf) {
			await Controllers[phase]()
		}
	}
}

Controllers.getRedirectionMap = async (options = {}) => {
	Controllers.redirectTemplates = {
		categories: {},
		users: {},
		topics: {},
		posts: {},
	}

	Object.keys(Controllers.config().redirectionTemplates || {}).forEach((key) => {
		const model = Controllers.config().redirectionTemplates[key]
		if (model && model.oldPath && model.newPath) {
			Controllers.redirectTemplates[key].oldPath = _.template(model.oldPath)
			Controllers.redirectTemplates[key].newPath = _.template(model.newPath)
		}
	})

	const format = options.format || Controllers.config().redirectionFormat
	const _mainPids = {}

	let json = ''
	let csv = ''
	let nginxMaps = {
		users: '',
		categories: '',
		topics: '',
		posts: '',
	}

	if (!Controllers.postImportToolsAvailble()) {
		return Controllers.state({
			now: 'busy',
			event: 'controller.getRedirectionMap',
		})
	}

	if (Controllers.redirectTemplates.categories.oldPath && Controllers.redirectTemplates.categories.newPath) {
		const categoriesTotal = await Categories.count()
		let categoryIndex = 0
		await Categories.each(async (category) => {
			const __imported_original_data__ = utils.jsonParseSafe((category || {}).__imported_original_data__, {})
			if (category && __imported_original_data__._cid) {
				try {
					const oldPath = Controllers.redirectTemplates.categories.oldPath(__imported_original_data__)
					const newPath = Controllers.redirectTemplates.categories.newPath(category)
					json += `"${oldPath}":"${newPath}",\n`
					csv += `\n${oldPath},${newPath}`
					nginxMaps.categories += `\n${oldPath}\t${newPath};`
					categoryIndex += 1
					await Controllers.saveProgress({
						phase: 'getRedirectionMap:redirectCategories',
						count: categoryIndex,
						total: categoriesTotal
					})
				} catch (e) {
					console.warn(`_cid:${__imported_original_data__._cid}, cid:${category.cid}`, e.message)
				}
			}
		})
	}

	if (Controllers.redirectTemplates.topics.oldPath && Controllers.redirectTemplates.topics.newPath) {
		const topicsTotal = await Topics.count()
		let topicsIndex = 0
		await Topics.each(async (topic) => {
			topicsIndex += 1
			const __imported_original_data__ = utils.jsonParseSafe((topic || {}).__imported_original_data__, {})
			_mainPids[topic.mainPid] = 1

			if (topic && __imported_original_data__._tid) {
				const oldPath = Controllers.redirectTemplates.topics.oldPath(__imported_original_data__)
				const newPath = Controllers.redirectTemplates.topics.newPath(topic)
				json += `"${oldPath}":"${newPath}",\n`
				csv += `\n${oldPath},${newPath}`
				nginxMaps.topics += `\n${oldPath}\t${newPath};`
			}

			await Controllers.saveProgress({
				phase: 'getRedirectionMap:redirectTopics',
				count: topicsIndex,
				total: topicsTotal
			})
		})
	}

	if (Controllers.redirectTemplates.posts.oldPath && Controllers.redirectTemplates.posts.newPath) {
		const postsTotal = await Posts.count()
		let postsIndex = 0
		await Posts.each(async (post) => {
			const __imported_original_data__ = utils.jsonParseSafe((post || {}).__imported_original_data__, {})
			postsIndex += 1

			if (post && __imported_original_data__._pid && !_mainPids[post.pid]) {
				const oldPath = Controllers.redirectTemplates.posts.oldPath(__imported_original_data__)
				const newPath = Controllers.redirectTemplates.posts.newPath(post)
				json += `"${oldPath}":"${newPath}",\n`
				csv += `\n${oldPath},${newPath}`
				nginxMaps.posts += `\n${oldPath}\t${newPath};`
			}

			await Controllers.saveProgress({
				phase: 'getRedirectionMap:redirectTopics',
				count: postsIndex,
				total: postsTotal
			})
		})
	}

	const lastCommaIdx = json.lastIndexOf(',')
	if (lastCommaIdx > -1) {
		json = json.substring(0, lastCommaIdx)
	}
	json += '\n}'

	if (format === 'nginx') {
		const filenames = []
		const contents = []
		const filepaths = []
		const fileurls = []
		Object.keys(nginxMaps).forEach((key) => {
			if (nginxMaps[key]) {
				let filename = `${key}.nginx.redirect.map`
				filenames.push(filename)
				contents.push(nginxMaps[key])
				filepaths.push(path.join(DELIVERABLES_TMP_DIR, `/${filename}`))
				fileurls.push(`${DELIVERABLES_TMP_DIR}/${filename}`)
			}
		})

		await Promise.all(filepaths.map((filepath, i) => fs.writeFile(filepath, contents[i], 'utf-8')))

		Controllers.state({
			now: 'idle',
			event: 'controller.download',
		})

		return {
			filenames,
			fileurls,
			filepaths,
			contents
		}
	}

	const filename = format === 'json' ? 'redirect.map.json' : 'redirect.map.csv'
	const content = format === 'json' ? json : csv
	const filepath = path.join(DELIVERABLES_TMP_DIR, `/${filename}`)
	const fileurl = `${DELIVERABLES_TMP_URL}/${filename}`

	Controllers.state({
		now: 'idle',
		event: 'controller.download',
	})

	await fs.writeFile(filepath, content, 'utf-8')

	return {
		filename,
		fileurl,
		filepath
	}
}

Controllers.postImport = async () => {
	await Controllers.setupConvert()
	await Controllers.convertAll()
	await Controllers.getRedirectionMap()
	await Controllers.deleteExtraFields()
}

Controllers.saveProgress = (data = {}) => {
	const progress = (data.count / data.total) * 100
	helpers.printProgress(progress)
	data.timestamp = data.timestamp || moment().format()
	return db.setObject('controller:progress', data)
}

Controllers.getProgress = () => db.getObject('controller:progress')

Controllers.clearProgress = () => db.delete('controller:progress')

module.exports = Controllers